// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SearchRequest search request
//
// swagger:model SearchRequest
type SearchRequest struct {

	// Filter by asset status label.
	// Unique: true
	AssetStatus []string `json:"assetStatus"`

	// Filter by categories.
	// Unique: true
	Category []string `json:"category"`

	// Filter by range of date that the resource was created.
	CreatedRange *Range `json:"createdRange,omitempty"`

	// Minimum access level to filter by.
	// Enum: [NONE SAML_GATED DISCOVER MEMBER READ WRITE ADMIN]
	MinAccessLevel string `json:"minAccessLevel,omitempty"`

	// Filter by owners. Owners are identified by their IDs.
	// Unique: true
	Owner []string `json:"owner"`

	// query
	// Required: true
	Query *string `json:"query"`

	// Filter by tags.
	// Unique: true
	Tag []string `json:"tag"`

	// Filter by type of metadata resource. Both IRI and label are accepted.
	// Unique: true
	Type []string `json:"type"`

	// Filter by range of date that the resource was updated.
	UpdatedRange *Range `json:"updatedRange,omitempty"`

	// Filter by visibility.
	// Enum: [DISCOVERABLE OPEN PRIVATE]
	Visibility string `json:"visibility,omitempty"`
}

// Validate validates this search request
func (m *SearchRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAssetStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedRange(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMinAccessLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOwner(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuery(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedRange(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVisibility(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SearchRequest) validateAssetStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.AssetStatus) { // not required
		return nil
	}

	if err := validate.UniqueItems("assetStatus", "body", m.AssetStatus); err != nil {
		return err
	}

	return nil
}

var searchRequestCategoryItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["catalogAnalysis","catalogBusinessTerm","catalogDataType","catalogTable","collection","comment","dataset","datatable","file","insight","integration","project","query","unknownCatalogEntry"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		searchRequestCategoryItemsEnum = append(searchRequestCategoryItemsEnum, v)
	}
}

func (m *SearchRequest) validateCategoryItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, searchRequestCategoryItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SearchRequest) validateCategory(formats strfmt.Registry) error {
	if swag.IsZero(m.Category) { // not required
		return nil
	}

	if err := validate.UniqueItems("category", "body", m.Category); err != nil {
		return err
	}

	for i := 0; i < len(m.Category); i++ {

		// value enum
		if err := m.validateCategoryItemsEnum("category"+"."+strconv.Itoa(i), "body", m.Category[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *SearchRequest) validateCreatedRange(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedRange) { // not required
		return nil
	}

	if m.CreatedRange != nil {
		if err := m.CreatedRange.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createdRange")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createdRange")
			}
			return err
		}
	}

	return nil
}

var searchRequestTypeMinAccessLevelPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NONE","SAML_GATED","DISCOVER","MEMBER","READ","WRITE","ADMIN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		searchRequestTypeMinAccessLevelPropEnum = append(searchRequestTypeMinAccessLevelPropEnum, v)
	}
}

const (

	// SearchRequestMinAccessLevelNONE captures enum value "NONE"
	SearchRequestMinAccessLevelNONE string = "NONE"

	// SearchRequestMinAccessLevelSAMLGATED captures enum value "SAML_GATED"
	SearchRequestMinAccessLevelSAMLGATED string = "SAML_GATED"

	// SearchRequestMinAccessLevelDISCOVER captures enum value "DISCOVER"
	SearchRequestMinAccessLevelDISCOVER string = "DISCOVER"

	// SearchRequestMinAccessLevelMEMBER captures enum value "MEMBER"
	SearchRequestMinAccessLevelMEMBER string = "MEMBER"

	// SearchRequestMinAccessLevelREAD captures enum value "READ"
	SearchRequestMinAccessLevelREAD string = "READ"

	// SearchRequestMinAccessLevelWRITE captures enum value "WRITE"
	SearchRequestMinAccessLevelWRITE string = "WRITE"

	// SearchRequestMinAccessLevelADMIN captures enum value "ADMIN"
	SearchRequestMinAccessLevelADMIN string = "ADMIN"
)

// prop value enum
func (m *SearchRequest) validateMinAccessLevelEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, searchRequestTypeMinAccessLevelPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SearchRequest) validateMinAccessLevel(formats strfmt.Registry) error {
	if swag.IsZero(m.MinAccessLevel) { // not required
		return nil
	}

	// value enum
	if err := m.validateMinAccessLevelEnum("minAccessLevel", "body", m.MinAccessLevel); err != nil {
		return err
	}

	return nil
}

func (m *SearchRequest) validateOwner(formats strfmt.Registry) error {
	if swag.IsZero(m.Owner) { // not required
		return nil
	}

	if err := validate.UniqueItems("owner", "body", m.Owner); err != nil {
		return err
	}

	return nil
}

func (m *SearchRequest) validateQuery(formats strfmt.Registry) error {

	if err := validate.Required("query", "body", m.Query); err != nil {
		return err
	}

	return nil
}

func (m *SearchRequest) validateTag(formats strfmt.Registry) error {
	if swag.IsZero(m.Tag) { // not required
		return nil
	}

	if err := validate.UniqueItems("tag", "body", m.Tag); err != nil {
		return err
	}

	return nil
}

func (m *SearchRequest) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	if err := validate.UniqueItems("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

func (m *SearchRequest) validateUpdatedRange(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdatedRange) { // not required
		return nil
	}

	if m.UpdatedRange != nil {
		if err := m.UpdatedRange.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updatedRange")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updatedRange")
			}
			return err
		}
	}

	return nil
}

var searchRequestTypeVisibilityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DISCOVERABLE","OPEN","PRIVATE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		searchRequestTypeVisibilityPropEnum = append(searchRequestTypeVisibilityPropEnum, v)
	}
}

const (

	// SearchRequestVisibilityDISCOVERABLE captures enum value "DISCOVERABLE"
	SearchRequestVisibilityDISCOVERABLE string = "DISCOVERABLE"

	// SearchRequestVisibilityOPEN captures enum value "OPEN"
	SearchRequestVisibilityOPEN string = "OPEN"

	// SearchRequestVisibilityPRIVATE captures enum value "PRIVATE"
	SearchRequestVisibilityPRIVATE string = "PRIVATE"
)

// prop value enum
func (m *SearchRequest) validateVisibilityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, searchRequestTypeVisibilityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SearchRequest) validateVisibility(formats strfmt.Registry) error {
	if swag.IsZero(m.Visibility) { // not required
		return nil
	}

	// value enum
	if err := m.validateVisibilityEnum("visibility", "body", m.Visibility); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this search request based on the context it is used
func (m *SearchRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCreatedRange(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdatedRange(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SearchRequest) contextValidateCreatedRange(ctx context.Context, formats strfmt.Registry) error {

	if m.CreatedRange != nil {
		if err := m.CreatedRange.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createdRange")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createdRange")
			}
			return err
		}
	}

	return nil
}

func (m *SearchRequest) contextValidateUpdatedRange(ctx context.Context, formats strfmt.Registry) error {

	if m.UpdatedRange != nil {
		if err := m.UpdatedRange.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updatedRange")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updatedRange")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SearchRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SearchRequest) UnmarshalBinary(b []byte) error {
	var res SearchRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
