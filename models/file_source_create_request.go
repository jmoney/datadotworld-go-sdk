// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FileSourceCreateRequest file source create request
//
// swagger:model FileSourceCreateRequest
type FileSourceCreateRequest struct {

	// authorization
	Authorization *WebAuthorization `json:"authorization,omitempty"`

	// credentials
	Credentials *WebCredentials `json:"credentials,omitempty"`

	// data tables
	DataTables map[string]QueryExecutionDto `json:"dataTables,omitempty"`

	// database metadata spec
	DatabaseMetadataSpec *DatabaseMetadataSpecDto `json:"databaseMetadataSpec,omitempty"`

	// database source
	DatabaseSource *DatabaseSourceReference `json:"databaseSource,omitempty"`

	// dwcc spec
	DwccSpec *DwccSpecDto `json:"dwccSpec,omitempty"`

	// expand archive
	ExpandArchive *bool `json:"expandArchive,omitempty"`

	// method
	// Enum: [GET POST]
	Method string `json:"method,omitempty"`

	// oauth token
	OauthToken *OauthTokenReference `json:"oauthToken,omitempty"`

	// request entity
	// Max Length: 10000
	// Min Length: 0
	RequestEntity *string `json:"requestEntity,omitempty"`

	// request headers
	RequestHeaders map[string]string `json:"requestHeaders,omitempty"`

	// table spec
	TableSpec *SingleTableMetadataSpecDto `json:"tableSpec,omitempty"`

	// url
	// Format: uri
	URL strfmt.URI `json:"url,omitempty"`

	// view request
	ViewRequest *ViewRequestDto `json:"viewRequest,omitempty"`
}

// Validate validates this file source create request
func (m *FileSourceCreateRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthorization(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCredentials(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataTables(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDatabaseMetadataSpec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDatabaseSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDwccSpec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOauthToken(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequestEntity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTableSpec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateViewRequest(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileSourceCreateRequest) validateAuthorization(formats strfmt.Registry) error {
	if swag.IsZero(m.Authorization) { // not required
		return nil
	}

	if m.Authorization != nil {
		if err := m.Authorization.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authorization")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("authorization")
			}
			return err
		}
	}

	return nil
}

func (m *FileSourceCreateRequest) validateCredentials(formats strfmt.Registry) error {
	if swag.IsZero(m.Credentials) { // not required
		return nil
	}

	if m.Credentials != nil {
		if err := m.Credentials.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("credentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("credentials")
			}
			return err
		}
	}

	return nil
}

func (m *FileSourceCreateRequest) validateDataTables(formats strfmt.Registry) error {
	if swag.IsZero(m.DataTables) { // not required
		return nil
	}

	for k := range m.DataTables {

		if err := validate.Required("dataTables"+"."+k, "body", m.DataTables[k]); err != nil {
			return err
		}
		if val, ok := m.DataTables[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dataTables" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dataTables" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *FileSourceCreateRequest) validateDatabaseMetadataSpec(formats strfmt.Registry) error {
	if swag.IsZero(m.DatabaseMetadataSpec) { // not required
		return nil
	}

	if m.DatabaseMetadataSpec != nil {
		if err := m.DatabaseMetadataSpec.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("databaseMetadataSpec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("databaseMetadataSpec")
			}
			return err
		}
	}

	return nil
}

func (m *FileSourceCreateRequest) validateDatabaseSource(formats strfmt.Registry) error {
	if swag.IsZero(m.DatabaseSource) { // not required
		return nil
	}

	if m.DatabaseSource != nil {
		if err := m.DatabaseSource.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("databaseSource")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("databaseSource")
			}
			return err
		}
	}

	return nil
}

func (m *FileSourceCreateRequest) validateDwccSpec(formats strfmt.Registry) error {
	if swag.IsZero(m.DwccSpec) { // not required
		return nil
	}

	if m.DwccSpec != nil {
		if err := m.DwccSpec.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dwccSpec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dwccSpec")
			}
			return err
		}
	}

	return nil
}

var fileSourceCreateRequestTypeMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["GET","POST"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fileSourceCreateRequestTypeMethodPropEnum = append(fileSourceCreateRequestTypeMethodPropEnum, v)
	}
}

const (

	// FileSourceCreateRequestMethodGET captures enum value "GET"
	FileSourceCreateRequestMethodGET string = "GET"

	// FileSourceCreateRequestMethodPOST captures enum value "POST"
	FileSourceCreateRequestMethodPOST string = "POST"
)

// prop value enum
func (m *FileSourceCreateRequest) validateMethodEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fileSourceCreateRequestTypeMethodPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FileSourceCreateRequest) validateMethod(formats strfmt.Registry) error {
	if swag.IsZero(m.Method) { // not required
		return nil
	}

	// value enum
	if err := m.validateMethodEnum("method", "body", m.Method); err != nil {
		return err
	}

	return nil
}

func (m *FileSourceCreateRequest) validateOauthToken(formats strfmt.Registry) error {
	if swag.IsZero(m.OauthToken) { // not required
		return nil
	}

	if m.OauthToken != nil {
		if err := m.OauthToken.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oauthToken")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oauthToken")
			}
			return err
		}
	}

	return nil
}

func (m *FileSourceCreateRequest) validateRequestEntity(formats strfmt.Registry) error {
	if swag.IsZero(m.RequestEntity) { // not required
		return nil
	}

	if err := validate.MinLength("requestEntity", "body", *m.RequestEntity, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("requestEntity", "body", *m.RequestEntity, 10000); err != nil {
		return err
	}

	return nil
}

func (m *FileSourceCreateRequest) validateTableSpec(formats strfmt.Registry) error {
	if swag.IsZero(m.TableSpec) { // not required
		return nil
	}

	if m.TableSpec != nil {
		if err := m.TableSpec.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tableSpec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tableSpec")
			}
			return err
		}
	}

	return nil
}

func (m *FileSourceCreateRequest) validateURL(formats strfmt.Registry) error {
	if swag.IsZero(m.URL) { // not required
		return nil
	}

	if err := validate.FormatOf("url", "body", "uri", m.URL.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *FileSourceCreateRequest) validateViewRequest(formats strfmt.Registry) error {
	if swag.IsZero(m.ViewRequest) { // not required
		return nil
	}

	if m.ViewRequest != nil {
		if err := m.ViewRequest.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("viewRequest")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("viewRequest")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file source create request based on the context it is used
func (m *FileSourceCreateRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAuthorization(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCredentials(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDataTables(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDatabaseMetadataSpec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDatabaseSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDwccSpec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOauthToken(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTableSpec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateViewRequest(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileSourceCreateRequest) contextValidateAuthorization(ctx context.Context, formats strfmt.Registry) error {

	if m.Authorization != nil {
		if err := m.Authorization.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authorization")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("authorization")
			}
			return err
		}
	}

	return nil
}

func (m *FileSourceCreateRequest) contextValidateCredentials(ctx context.Context, formats strfmt.Registry) error {

	if m.Credentials != nil {
		if err := m.Credentials.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("credentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("credentials")
			}
			return err
		}
	}

	return nil
}

func (m *FileSourceCreateRequest) contextValidateDataTables(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.DataTables {

		if val, ok := m.DataTables[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *FileSourceCreateRequest) contextValidateDatabaseMetadataSpec(ctx context.Context, formats strfmt.Registry) error {

	if m.DatabaseMetadataSpec != nil {
		if err := m.DatabaseMetadataSpec.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("databaseMetadataSpec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("databaseMetadataSpec")
			}
			return err
		}
	}

	return nil
}

func (m *FileSourceCreateRequest) contextValidateDatabaseSource(ctx context.Context, formats strfmt.Registry) error {

	if m.DatabaseSource != nil {
		if err := m.DatabaseSource.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("databaseSource")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("databaseSource")
			}
			return err
		}
	}

	return nil
}

func (m *FileSourceCreateRequest) contextValidateDwccSpec(ctx context.Context, formats strfmt.Registry) error {

	if m.DwccSpec != nil {
		if err := m.DwccSpec.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dwccSpec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dwccSpec")
			}
			return err
		}
	}

	return nil
}

func (m *FileSourceCreateRequest) contextValidateOauthToken(ctx context.Context, formats strfmt.Registry) error {

	if m.OauthToken != nil {
		if err := m.OauthToken.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oauthToken")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oauthToken")
			}
			return err
		}
	}

	return nil
}

func (m *FileSourceCreateRequest) contextValidateTableSpec(ctx context.Context, formats strfmt.Registry) error {

	if m.TableSpec != nil {
		if err := m.TableSpec.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tableSpec")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tableSpec")
			}
			return err
		}
	}

	return nil
}

func (m *FileSourceCreateRequest) contextValidateViewRequest(ctx context.Context, formats strfmt.Registry) error {

	if m.ViewRequest != nil {
		if err := m.ViewRequest.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("viewRequest")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("viewRequest")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileSourceCreateRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileSourceCreateRequest) UnmarshalBinary(b []byte) error {
	var res FileSourceCreateRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
