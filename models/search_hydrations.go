// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SearchHydrations search hydrations
//
// swagger:model SearchHydrations
type SearchHydrations struct {

	// agents
	Agents map[string]AgentHydrationDto `json:"agents,omitempty"`

	// catalog analysis
	CatalogAnalysis map[string]CatalogAnalysisHydrationDto `json:"catalogAnalysis,omitempty"`

	// catalog business terms
	CatalogBusinessTerms map[string]CatalogBusinessTermHydrationDto `json:"catalogBusinessTerms,omitempty"`

	// catalog columns
	CatalogColumns map[string]CatalogColumnHydrationDto `json:"catalogColumns,omitempty"`

	// catalog concepts
	CatalogConcepts map[string]CatalogConceptHydrationDto `json:"catalogConcepts,omitempty"`

	// catalog tables
	CatalogTables map[string]CatalogTableHydrationDto `json:"catalogTables,omitempty"`

	// catalogs
	Catalogs map[string]CatalogHydrationDto `json:"catalogs,omitempty"`

	// datasets
	Datasets map[string]DatasetHydrationDto `json:"datasets,omitempty"`

	// insights
	Insights map[string]InsightHydrationDto `json:"insights,omitempty"`

	// unknown catalog entry
	UnknownCatalogEntry map[string]UnknownCatalogEntryHydrationDto `json:"unknownCatalogEntry,omitempty"`
}

// Validate validates this search hydrations
func (m *SearchHydrations) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAgents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCatalogAnalysis(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCatalogBusinessTerms(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCatalogColumns(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCatalogConcepts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCatalogTables(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCatalogs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDatasets(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInsights(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUnknownCatalogEntry(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SearchHydrations) validateAgents(formats strfmt.Registry) error {
	if swag.IsZero(m.Agents) { // not required
		return nil
	}

	for k := range m.Agents {

		if err := validate.Required("agents"+"."+k, "body", m.Agents[k]); err != nil {
			return err
		}
		if val, ok := m.Agents[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("agents" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("agents" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *SearchHydrations) validateCatalogAnalysis(formats strfmt.Registry) error {
	if swag.IsZero(m.CatalogAnalysis) { // not required
		return nil
	}

	for k := range m.CatalogAnalysis {

		if err := validate.Required("catalogAnalysis"+"."+k, "body", m.CatalogAnalysis[k]); err != nil {
			return err
		}
		if val, ok := m.CatalogAnalysis[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("catalogAnalysis" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("catalogAnalysis" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *SearchHydrations) validateCatalogBusinessTerms(formats strfmt.Registry) error {
	if swag.IsZero(m.CatalogBusinessTerms) { // not required
		return nil
	}

	for k := range m.CatalogBusinessTerms {

		if err := validate.Required("catalogBusinessTerms"+"."+k, "body", m.CatalogBusinessTerms[k]); err != nil {
			return err
		}
		if val, ok := m.CatalogBusinessTerms[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("catalogBusinessTerms" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("catalogBusinessTerms" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *SearchHydrations) validateCatalogColumns(formats strfmt.Registry) error {
	if swag.IsZero(m.CatalogColumns) { // not required
		return nil
	}

	for k := range m.CatalogColumns {

		if err := validate.Required("catalogColumns"+"."+k, "body", m.CatalogColumns[k]); err != nil {
			return err
		}
		if val, ok := m.CatalogColumns[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("catalogColumns" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("catalogColumns" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *SearchHydrations) validateCatalogConcepts(formats strfmt.Registry) error {
	if swag.IsZero(m.CatalogConcepts) { // not required
		return nil
	}

	for k := range m.CatalogConcepts {

		if err := validate.Required("catalogConcepts"+"."+k, "body", m.CatalogConcepts[k]); err != nil {
			return err
		}
		if val, ok := m.CatalogConcepts[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("catalogConcepts" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("catalogConcepts" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *SearchHydrations) validateCatalogTables(formats strfmt.Registry) error {
	if swag.IsZero(m.CatalogTables) { // not required
		return nil
	}

	for k := range m.CatalogTables {

		if err := validate.Required("catalogTables"+"."+k, "body", m.CatalogTables[k]); err != nil {
			return err
		}
		if val, ok := m.CatalogTables[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("catalogTables" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("catalogTables" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *SearchHydrations) validateCatalogs(formats strfmt.Registry) error {
	if swag.IsZero(m.Catalogs) { // not required
		return nil
	}

	for k := range m.Catalogs {

		if err := validate.Required("catalogs"+"."+k, "body", m.Catalogs[k]); err != nil {
			return err
		}
		if val, ok := m.Catalogs[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("catalogs" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("catalogs" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *SearchHydrations) validateDatasets(formats strfmt.Registry) error {
	if swag.IsZero(m.Datasets) { // not required
		return nil
	}

	for k := range m.Datasets {

		if err := validate.Required("datasets"+"."+k, "body", m.Datasets[k]); err != nil {
			return err
		}
		if val, ok := m.Datasets[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("datasets" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("datasets" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *SearchHydrations) validateInsights(formats strfmt.Registry) error {
	if swag.IsZero(m.Insights) { // not required
		return nil
	}

	for k := range m.Insights {

		if err := validate.Required("insights"+"."+k, "body", m.Insights[k]); err != nil {
			return err
		}
		if val, ok := m.Insights[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("insights" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("insights" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *SearchHydrations) validateUnknownCatalogEntry(formats strfmt.Registry) error {
	if swag.IsZero(m.UnknownCatalogEntry) { // not required
		return nil
	}

	for k := range m.UnknownCatalogEntry {

		if err := validate.Required("unknownCatalogEntry"+"."+k, "body", m.UnknownCatalogEntry[k]); err != nil {
			return err
		}
		if val, ok := m.UnknownCatalogEntry[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("unknownCatalogEntry" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("unknownCatalogEntry" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this search hydrations based on the context it is used
func (m *SearchHydrations) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAgents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCatalogAnalysis(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCatalogBusinessTerms(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCatalogColumns(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCatalogConcepts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCatalogTables(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCatalogs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDatasets(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInsights(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUnknownCatalogEntry(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SearchHydrations) contextValidateAgents(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.Agents {

		if val, ok := m.Agents[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *SearchHydrations) contextValidateCatalogAnalysis(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.CatalogAnalysis {

		if val, ok := m.CatalogAnalysis[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *SearchHydrations) contextValidateCatalogBusinessTerms(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.CatalogBusinessTerms {

		if val, ok := m.CatalogBusinessTerms[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *SearchHydrations) contextValidateCatalogColumns(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.CatalogColumns {

		if val, ok := m.CatalogColumns[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *SearchHydrations) contextValidateCatalogConcepts(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.CatalogConcepts {

		if val, ok := m.CatalogConcepts[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *SearchHydrations) contextValidateCatalogTables(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.CatalogTables {

		if val, ok := m.CatalogTables[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *SearchHydrations) contextValidateCatalogs(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.Catalogs {

		if val, ok := m.Catalogs[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *SearchHydrations) contextValidateDatasets(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.Datasets {

		if val, ok := m.Datasets[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *SearchHydrations) contextValidateInsights(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.Insights {

		if val, ok := m.Insights[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *SearchHydrations) contextValidateUnknownCatalogEntry(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.UnknownCatalogEntry {

		if val, ok := m.UnknownCatalogEntry[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *SearchHydrations) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SearchHydrations) UnmarshalBinary(b []byte) error {
	var res SearchHydrations
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
